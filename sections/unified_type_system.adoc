== Unified Type System - Any, AnyRef, AnyVal

We refer to Scala's type system as being "unified" because there is a "Top Type", called `Any`. **This is different from Java**, which has "special case" for
 primitive types (`int`, `long`, `float`, `double`, `byte`, `char`, `short`, `boolean`), which do not extend the Java's "Almost-Top Type", the well known -
 `java
 .lang.Object`.

image::assets/img/scala-types.png[Scala's Unified Type System, align="center"]

Scala takes on the idea of having one common Top Type for all Types by introducing `Any`. `Any` is a supertype of both `AnyRef` and `AnyVal`.

`AnyRef` represents the "object world" of Java (and the JVM), it corresponds to `java.lang.Object`, and is the supertype of all objects. `AnyVal` on the other
hand represents the "value world" of Java, such as `int` and other JVM primitives.

Thanks to this hierarchy, we're able to define methods taking `Any` - thus being compatible with both `scala.Int` instances as well as `java.lang.String`:

```scala
class Person

val allThings = ArrayBuffer[Any]()

val myInt = 42             // Int, kept as low-level `int` during runtime

allThings += myInt         // Int (extends AnyVal)
                           // has to be boxed (!) -> becomes java.lang.Integer in the collection (!)

allThings += new Person()  // Person (extends AnyRef), no magic here
```

The type system handles integration or co-existence of values and objects transparently, though on the JVM level once we get into `ArrayBuffer[Any]` our Int
instances
will have to be packed into objects.
Let's investigate the above example using the Scala REPL and its `:javap` command (which shows the generated bytecode for our test class):

```
35: invokevirtual #47  // Method myInt:()I
38: invokestatic  #53  // Method scala/runtime/BoxesRunTime.boxToInteger:(I)Ljava/lang/Integer;
41: invokevirtual #57  // Method scala/collection/mutable/ArrayBuffer.$plus$eq:(Ljava/lang/Object;)Lscala/collection/mutable/ArrayBuffer;
```

You'll notice that `myInt` is still carrying the value of a `int primitive` (this is visible as `I` at the end of the `myInt:()I` *invokevirtual* call).
Then, right before adding it to the ArrayBuffer, scalac inserts a call to `BoxesRunTime.boxToInteger:(I)Ljava/lang/Integer` (a small hint for not frequent
bytecode readers, the method it calls is: `public Integer boxToInteger(i: int)`). This way, by having a smart compiler and treating everything as an object
in this common hierarchy we're able to get away from the "but primitives are different" edge-cases, at least as far as the Scala-only portion of code is
concerned - the compiler takes care of it for us. At the JVM level, the distinction is still there of course, and scalac will do its best to keep using
primitives wherever possible, as operations on them are faster, and consume less memory (objects being obviously bigger than primitives).


On the other hand, we can limit a method to be able to work only on "lightweight" Value Types:

```scala
def check(in: AnyVal) = ()

check(42)    // Int -> AnyVal
check(13.37) // Double -> AnyVal

check(new Object) // -> AnyRef = fails to compile

```

In the above example I've used a TypeClass `Checker[T]` and a type bound, which will be discussed below. The general idea is that this method will only take
<<value-class, Value Classes>>, be it Int or our own Value Type. While probably not used very often, it shows how nicely the type system embraces java primitives, and brings them into the "real" type system, and not as a separate case, as is the case with Java.


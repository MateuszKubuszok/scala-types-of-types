== Structural Type

Strucural Types are often described as "*type-safe duck typing*", which is quite a good comparison if you want to gain some intuition for it.

So far we've only been thinking about types in terms of "*does it implement interface X?*". With **structural types** we can go a step further and start reasoning
about the structure of a given object (hence the name). When checking whether a type matches using structual typing, we need to change our question to:"*does it have a method with this signature?*".

Let's look at a very popular use-case in action, to see why it is so powerful. Imagine that you have many classes of things that can be *closed*. In Java-land one would usually implement the `java.io.Closeable` interface in order to make it possible to write some common `Closeable` utility classes (in fact, *Google Guava* provides such a utility class). Now imagine that someone also implemented a `MyOwnCloseable` class but didn't extend `java.io.Closeable`. Your `Closeables` library would not work here due to the static typing. You would not be able to pass instances of `MyOwnCloseable` into it. Let's solve this problem using Structural Typing:

```scala
type JavaCloseable = java.io.Closeable
// reminder, it's body is: { def close(): Unit }

class MyOwnCloseable {
  def close(): Unit = ()
}


// method taking a Structural Type
def closeQuietly(closeable: { def close(): Unit }) =
  try {
    closeable.close()
  } catch {
    case ex: Exception => // ignore...
  }


// accepts a java.io.File (implements Closeable):
closeQuietly(new StringReader("example"))

// accepts a MyOwnCloseable
closeQuietly(new MyOwnCloseable)
```

The structural type is defined as a parameter to the method. It basically says that the only thing we expect from the type is that it should have this method. It could have more methods - so it's not an exact match but the minimal set of methods a type has to define in order to be valid.

Another fact to keep in mind when using **Structural Typing is that it actually has huge (negative) runtime performance implications, as it is actually implemented using reflection**. We won't look into the byte code for this case, but remember that it's very easy to investigate the generated bytecode for scala (or java) classes, by using :javap in the Scala REPL. So you should try this out yourself.

Before we move over to the next subject, let's briefly touch on a small but neat style tip. Imagine that your Structural Type is quite big, an example would be a type representing something that you can open, work on, and then must close. By using a Type Alias (described in detail in another section) with a Structural Type, we're able to separate the type definition from the method, where we want to take in such instance:

```scala
type OpenerCloser = {
  def open(): Unit
  def close(): Unit
}

def on(it: OpenerCloser)(fun: OpenerCloser => Unit) = {
  it.open()
  fun(it)
  it.close()
}
```

So using this type alias, we've made the `def` much cleaner. I'd highly recommend type aliasing bigger structural types. And one last warning, always check if you really need to reach for structural typing, and cannot do it in some other way, considering the negative performance impact.

